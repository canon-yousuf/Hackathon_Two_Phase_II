---
name: database
description: Neon Serverless PostgreSQL + SQLModel patterns — schema design, models, connection setup, migrations, indexing, query patterns, and service layer for the Todo app.
---

# Database Skill — Neon Serverless PostgreSQL + SQLModel

## Overview
This skill provides the complete database implementation pattern for a Full-Stack monorepo using **SQLModel ORM** with **Neon Serverless PostgreSQL**. Covers schema design, model definitions, connection setup, migrations, indexing, and query patterns.

---

## Schema (from Hackathon Doc)

### Table: `user` (Managed by Better Auth)
> Better Auth auto-creates this table. Backend reads from it but NEVER writes to it.

| Column | Type | Constraints |
|--------|------|-------------|
| id | TEXT | Primary Key (generated by Better Auth) |
| email | TEXT | Unique, Not Null |
| name | TEXT | Not Null |
| emailVerified | BOOLEAN | Default FALSE |
| image | TEXT | Nullable |
| createdAt | TIMESTAMP | Default NOW() |
| updatedAt | TIMESTAMP | Default NOW() |

Better Auth also auto-creates `session` and `account` tables.

### Table: `tasks`

| Column | Type | Constraints |
|--------|------|-------------|
| id | INTEGER | Primary Key, Auto-increment |
| user_id | TEXT | Foreign Key → user.id, Not Null, Indexed |
| title | VARCHAR(200) | Not Null |
| description | TEXT | Nullable |
| completed | BOOLEAN | Default FALSE, Indexed |
| created_at | TIMESTAMP | Default NOW() |
| updated_at | TIMESTAMP | Default NOW(), Auto-update |

### Indexes

| Index | Column(s) | Purpose |
|-------|-----------|---------|
| idx_tasks_user_id | tasks.user_id | Filter tasks by user |
| idx_tasks_completed | tasks.completed | Filter by completion status |
| idx_tasks_created_at | tasks.created_at | Sort by creation date |

---

## SQLModel Definitions

### Task Model
**File**: `backend/app/models/task.py`
```python
from sqlmodel import SQLModel, Field
from datetime import datetime, timezone
from typing import Optional


class TaskBase(SQLModel):
    """Shared fields for Task creation and response."""
    title: str = Field(max_length=200, min_length=1)
    description: Optional[str] = Field(default=None, max_length=1000)


class Task(TaskBase, table=True):
    """Database table model for tasks."""
    __tablename__ = "tasks"

    id: Optional[int] = Field(default=None, primary_key=True)
    user_id: str = Field(foreign_key="user.id", index=True, nullable=False)
    completed: bool = Field(default=False, index=True)
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc)
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        sa_column_kwargs={"onupdate": lambda: datetime.now(timezone.utc)},
    )


class TaskCreate(TaskBase):
    """Request schema for creating a task."""
    pass


class TaskUpdate(SQLModel):
    """Request schema for updating a task. All fields optional."""
    title: Optional[str] = Field(default=None, max_length=200, min_length=1)
    description: Optional[str] = Field(default=None, max_length=1000)


class TaskResponse(TaskBase):
    """Response schema for a single task."""
    id: int
    user_id: str
    completed: bool
    created_at: datetime
    updated_at: datetime
```

---

## Neon Connection Setup

### Connection Config
**File**: `backend/app/db.py`
```python
import os
from sqlmodel import SQLModel, Session, create_engine

DATABASE_URL = os.environ["DATABASE_URL"]

# Neon requires SSL
# Connection string format: postgresql://user:pass@ep-xxx.neon.tech/dbname?sslmode=require

engine = create_engine(
    DATABASE_URL,
    echo=False,  # Set True for SQL debugging
    pool_pre_ping=True,  # Handle Neon cold starts
    pool_size=5,
    max_overflow=10,
    pool_recycle=300,  # Recycle connections every 5 min (Neon serverless)
)


def create_db_and_tables():
    """Create all tables. Call on app startup."""
    SQLModel.metadata.create_all(engine)


def get_session():
    """FastAPI dependency — yields a database session."""
    with Session(engine) as session:
        yield session
```

### App Startup Integration
**File**: `backend/app/main.py`
```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
from app.db import create_db_and_tables


@asynccontextmanager
async def lifespan(app: FastAPI):
    create_db_and_tables()
    yield


app = FastAPI(title="Todo API", lifespan=lifespan)
```

---

## Neon-Specific Considerations

| Concern | Solution |
|---------|----------|
| SSL Required | Always use `?sslmode=require` in DATABASE_URL |
| Cold Starts | Set `pool_pre_ping=True` to detect stale connections |
| Connection Limits | Free tier: 20 connections. Use pooling settings above |
| Pooler URL | Neon provides a pooler endpoint (port 5432 direct, 6543 pooled). Use pooled for production |
| Branching | Create dev/staging branches in Neon dashboard for safe testing |
| Idle Timeout | Neon suspends after 5 min inactivity. `pool_pre_ping` handles reconnection |

### DATABASE_URL Format
```
# Direct connection
postgresql://user:password@ep-cool-name-123456.us-east-2.aws.neon.tech/todo_db?sslmode=require

# Pooled connection (recommended for production)
postgresql://user:password@ep-cool-name-123456.us-east-2.aws.neon.tech:6543/todo_db?sslmode=require
```

---

## Query Patterns

### Service Layer
**File**: `backend/app/services/task_service.py`
```python
from sqlmodel import Session, select, col
from app.models.task import Task, TaskCreate, TaskUpdate
from typing import Optional
from datetime import datetime, timezone


def get_tasks(
    session: Session,
    user_id: str,
    status: str = "all",
    sort: str = "created",
) -> list[Task]:
    """List tasks for a user with optional filtering and sorting."""
    statement = select(Task).where(Task.user_id == user_id)

    # Filter by status
    if status == "pending":
        statement = statement.where(Task.completed == False)
    elif status == "completed":
        statement = statement.where(Task.completed == True)

    # Sort
    if sort == "title":
        statement = statement.order_by(col(Task.title))
    elif sort == "created":
        statement = statement.order_by(col(Task.created_at).desc())

    return session.exec(statement).all()


def get_task(session: Session, user_id: str, task_id: int) -> Task | None:
    """Get a single task, ensuring it belongs to the user."""
    statement = select(Task).where(Task.id == task_id, Task.user_id == user_id)
    return session.exec(statement).first()


def create_task(session: Session, user_id: str, data: TaskCreate) -> Task:
    """Create a new task for the user."""
    task = Task(
        user_id=user_id,
        title=data.title,
        description=data.description,
    )
    session.add(task)
    session.commit()
    session.refresh(task)
    return task


def update_task(
    session: Session, user_id: str, task_id: int, data: TaskUpdate
) -> Task | None:
    """Update a task's title or description."""
    task = get_task(session, user_id, task_id)
    if not task:
        return None

    if data.title is not None:
        task.title = data.title
    if data.description is not None:
        task.description = data.description
    task.updated_at = datetime.now(timezone.utc)

    session.add(task)
    session.commit()
    session.refresh(task)
    return task


def delete_task(session: Session, user_id: str, task_id: int) -> bool:
    """Delete a task. Returns True if deleted, False if not found."""
    task = get_task(session, user_id, task_id)
    if not task:
        return False
    session.delete(task)
    session.commit()
    return True


def toggle_complete(session: Session, user_id: str, task_id: int) -> Task | None:
    """Toggle the completed status of a task."""
    task = get_task(session, user_id, task_id)
    if not task:
        return None
    task.completed = not task.completed
    task.updated_at = datetime.now(timezone.utc)
    session.add(task)
    session.commit()
    session.refresh(task)
    return task
```

---

## Migration Strategy

### Option A: SQLModel Auto-Create (Simple — Recommended for Hackathon)
```python
# On app startup
SQLModel.metadata.create_all(engine)
```
- Creates tables if they don't exist
- Does NOT alter existing tables
- Good for initial setup and hackathon

### Option B: Alembic (Production — For Schema Changes)
```bash
cd backend
pip install alembic
alembic init alembic
```

**File**: `backend/alembic/env.py` (key modification)
```python
from sqlmodel import SQLModel
from app.models.task import Task  # Import all models

target_metadata = SQLModel.metadata
```

Common commands:
```bash
alembic revision --autogenerate -m "add tasks table"
alembic upgrade head
alembic downgrade -1
alembic history
```

### When to Use Which
| Scenario | Use |
|----------|-----|
| First time setup | `create_all()` |
| Adding new table | `create_all()` works |
| Adding column to existing table | Alembic migration |
| Renaming/dropping column | Alembic migration |
| Hackathon rapid development | `create_all()` + recreate if needed |

---

## Data Integrity Rules

1. **Foreign Key**: `tasks.user_id` → `user.id`. Task cannot exist without a valid user
2. **Cascading**: If a user is deleted, their tasks should be deleted too
   ```python
   user_id: str = Field(
       foreign_key="user.id",
       sa_column_kwargs={"ondelete": "CASCADE"},
   )
   ```
3. **Validation at Model Level**:
   - `title`: 1–200 characters, required
   - `description`: max 1000 characters, optional
4. **User Isolation**: Every query MUST filter by `user_id`. Never return another user's tasks
5. **Timestamps**: `created_at` set once on creation, `updated_at` refreshed on every modification

---

## Testing Database

### Unit Tests (SQLite)
```python
from sqlmodel import SQLModel, create_engine, Session

TEST_ENGINE = create_engine("sqlite:///./test.db")

def setup():
    SQLModel.metadata.create_all(TEST_ENGINE)

def teardown():
    SQLModel.metadata.drop_all(TEST_ENGINE)
```

### Integration Tests (Neon Branch)
- Create a branch in Neon dashboard for testing
- Use branch connection string in test env
- Branch can be reset/deleted after tests

---

## Common Issues & Fixes

| Issue | Cause | Fix |
|-------|-------|-----|
| `SSL SYSCALL error` | Missing sslmode | Add `?sslmode=require` to DATABASE_URL |
| `connection refused` | Neon suspended | Retry — Neon auto-wakes on connection |
| `relation does not exist` | Tables not created | Call `create_db_and_tables()` on startup |
| `foreign key violation` | user_id doesn't exist in user table | Ensure Better Auth creates user first |
| `pool timeout` | Too many connections | Use pooled endpoint (port 6543) |
| `updated_at not changing` | Missing onupdate | Manually set `task.updated_at = datetime.now(timezone.utc)` in service |
| `duplicate key` | Race condition | Use DB-level unique constraints |
