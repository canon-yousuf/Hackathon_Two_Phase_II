# Implementation Plan: Backend API — All 6 REST Endpoints + Service Layer

**Branch**: `008-testing-strategy` | **Date**: 2026-02-08 | **Spec**: `specs/004-rest-api-endpoints/spec.md`
**Input**: Feature specifications from `specs/004-rest-api-endpoints/spec.md`, `specs/005-task-crud-features/spec.md`, `specs/002-database-schema/spec.md`, `specs/001-system-architecture/spec.md`

## Summary

Implement the complete backend API layer for the Todo application: a service layer with 6 database operations (list, get, create, update, delete, toggle) and 6 thin route handlers, plus error handling and app wiring. Foundation (DB connection, SQLModel models, JWT auth middleware) is already implemented. This plan adds the business logic and HTTP endpoint layers on top.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: FastAPI 0.115+, SQLModel 0.0.22+, PyJWT 2.9+, Pydantic V2
**Storage**: Neon Serverless PostgreSQL via SQLModel (already configured in `backend/app/db.py`)
**Testing**: pytest + httpx AsyncClient (testing is out of scope for this plan; see testing spec)
**Target Platform**: Linux/Windows server, `uvicorn` ASGI
**Project Type**: Web application (monorepo: `backend/` + `frontend/`)
**Performance Goals**: API responses < 1 second, health check < 2 seconds
**Constraints**: No pagination, no bulk ops, no search; exactly 6 endpoints under `/api/{user_id}/tasks`
**Scale/Scope**: Single-digit concurrent users during hackathon evaluation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Evidence |
|-----------|--------|----------|
| I. Spec-Driven Development | PASS | Specs exist: 001-system-architecture, 002-database-schema, 004-rest-api-endpoints, 005-task-crud-features |
| II. No Manual Coding | PASS | All code will be generated by Claude Code from specs via backend + database agents |
| III. User Isolation | PASS | Every service function takes `user_id`; every query filters by `user_id`; `enforce_user_access()` on every route |
| IV. Clean Architecture | PASS | Thin route handlers delegate to service layer; Pydantic schemas separate from DB models |
| V. Monorepo Coherence | PASS | All changes scoped to `backend/`; API contract documented in spec |

**Gate result**: ALL PASS. Proceed to implementation.

## Project Structure

### Documentation (this feature)

```text
.specify/plans/
├── plan-backend-api.md        # This file
├── research-backend-api.md    # Phase 0 output
├── data-model-backend-api.md  # Phase 1 output
└── quickstart-backend-api.md  # Phase 1 output
```

### Source Code (files to create/modify)

```text
backend/
├── app/
│   ├── main.py                     # MODIFY: register task router, add exception handler
│   ├── db.py                       # EXISTS: no changes needed
│   ├── config.py                   # EXISTS: no changes needed
│   ├── models/
│   │   └── task.py                 # EXISTS: no changes needed (TaskBase, Task, TaskCreate, TaskUpdate, TaskResponse)
│   ├── routes/
│   │   ├── __init__.py             # EXISTS: empty
│   │   └── tasks.py               # CREATE: 6 route handlers
│   ├── middleware/
│   │   └── auth.py                 # EXISTS: get_current_user, enforce_user_access
│   └── services/
│       ├── __init__.py             # EXISTS: empty
│       └── task_service.py         # CREATE: 6 service functions
```

**Structure Decision**: Web application pattern. All new code is in `backend/app/routes/tasks.py` and `backend/app/services/task_service.py`. One modification to `backend/app/main.py` for router registration and global error handling.

---

## Phase 0: Research

All unknowns have been resolved by reading existing foundation code. See `research-backend-api.md` for details.

**Key findings:**
- Foundation layer is fully implemented: `db.py`, `config.py`, `models/task.py`, `middleware/auth.py`, `main.py`
- DB session dependency uses sync `Session` (via `get_session` generator) — compatible with async route handlers
- Auth middleware provides `get_current_user` (returns `dict` with `user_id`, `email`, `name`) and `enforce_user_access`
- SQLModel `Task` model has all needed fields with proper indexes on `user_id` and `completed`
- Pydantic schemas `TaskCreate`, `TaskUpdate`, `TaskResponse` are ready to use
- `main.py` needs router registration and global exception handler added
- The `TaskUpdate` schema allows both `title` and `description` to be `None` — route handler must validate at least one is provided (422 if both None)

---

## Phase 1: Design & Contracts

### 1.1 Service Layer Design

**File**: `backend/app/services/task_service.py`

Six pure functions, each accepting a `Session` and `user_id` as first args. All queries are scoped to user_id. No HTTP concerns — only business logic and DB access.

| Function | Signature | Returns | Notes |
|----------|-----------|---------|-------|
| `get_tasks` | `(session, user_id, status="all", sort="created") -> list[Task]` | List of tasks | Filter by completed status, sort by created_at desc or title asc |
| `get_task` | `(session, user_id, task_id) -> Task | None` | Single task or None | WHERE id = task_id AND user_id = user_id |
| `create_task` | `(session, user_id, data: TaskCreate) -> Task` | Created task | Set user_id, commit, refresh, return |
| `update_task` | `(session, user_id, task_id, data: TaskUpdate) -> Task | None` | Updated task or None | Partial update, refresh updated_at |
| `delete_task` | `(session, user_id, task_id) -> bool` | True if deleted | Return False if not found |
| `toggle_complete` | `(session, user_id, task_id) -> Task | None` | Toggled task or None | Flip completed, refresh updated_at |

**User Isolation**: Every function filters by `user_id` in the WHERE clause. A task belonging to user A is invisible to user B at the data layer.

**Timestamp handling**: `created_at` is set by model default (never touched by service). `updated_at` is explicitly set to `datetime.now(timezone.utc)` in update and toggle operations.

### 1.2 Route Handlers Design

**File**: `backend/app/routes/tasks.py`

Router prefix: `/api/{user_id}/tasks` with tag `"tasks"`.

Every handler follows the same pattern:
1. Accept `user_id` path param, optional query/body params
2. Depend on `get_current_user` (401 if invalid token)
3. Call `enforce_user_access(user_id, current_user)` (403 if mismatch)
4. Call service function
5. Handle None returns (404)
6. Return response with correct status code

| Endpoint | Method | Path | Status | Request Body | Query Params | Response |
|----------|--------|------|--------|-------------|--------------|----------|
| List tasks | GET | `/api/{user_id}/tasks` | 200 | — | `status` (all/pending/completed), `sort` (created/title) | `list[TaskResponse]` |
| Create task | POST | `/api/{user_id}/tasks` | 201 | `TaskCreate` | — | `TaskResponse` |
| Get task | GET | `/api/{user_id}/tasks/{task_id}` | 200 | — | — | `TaskResponse` |
| Update task | PUT | `/api/{user_id}/tasks/{task_id}` | 200 | `TaskUpdate` | — | `TaskResponse` |
| Delete task | DELETE | `/api/{user_id}/tasks/{task_id}` | 204 | — | — | No body |
| Toggle complete | PATCH | `/api/{user_id}/tasks/{task_id}/complete` | 200 | — | — | `TaskResponse` |

**Query Parameter Validation**: Use FastAPI `Query` with `pattern` regex to restrict `status` to `^(all|pending|completed)$` and `sort` to `^(created|title)$`. Invalid values automatically return 422.

**Update Validation**: The PUT handler must check that at least one of `title` or `description` is not-None. If both are None/missing, return 422. This is a business rule enforced in the route handler (or could be a Pydantic `model_validator`, but route-level check is simpler and more explicit for this case).

**Edge Case — description set to null**: The spec says "A field explicitly set to null MUST clear that field". The `TaskUpdate` schema has `description: Optional[str] = None`. If a client sends `{"description": null}`, Pydantic will set it to `None`. The service layer must distinguish between "field not provided" and "field explicitly set to null". Solution: use `data.model_fields_set` to check which fields were explicitly included in the request body, and only update those fields. This handles the edge case where description is set to null (clears it) vs not included (leaves it unchanged).

### 1.3 Error Handling Design

**ErrorResponse schema**: A simple Pydantic model with `detail` (str) and `status_code` (int). Used in OpenAPI docs to document error responses.

**Global exception handler**: Catches unhandled exceptions and returns a 500 response with a generic error message. Prevents stack traces from leaking to clients.

**HTTP exception handling**: FastAPI's built-in `HTTPException` handler already returns `{"detail": "..."}`. We augment error responses to also include `status_code` in the body for frontend convenience.

**Validation errors**: FastAPI's `RequestValidationError` handler already returns 422 with validation details. No customization needed.

### 1.4 App Wiring Design

**Modifications to `main.py`**:
1. Import `tasks_router` from `app.routes.tasks`
2. Call `app.include_router(tasks_router)`
3. Add global exception handler for unhandled `Exception`

The health check endpoint, CORS middleware, and lifespan are already configured.

---

## Implementation Tasks (Dependency Order)

### Task 1: Create Service Layer
**File**: `backend/app/services/task_service.py`
**Agent**: Database Agent (query patterns)
**Depends on**: Foundation layer (existing)

Create all 6 service functions following the exact patterns from the database SKILL.md:
- `get_tasks(session, user_id, status, sort)` — select with filters and ordering
- `get_task(session, user_id, task_id)` — select with user_id + id
- `create_task(session, user_id, data)` — instantiate Task, add, commit, refresh
- `update_task(session, user_id, task_id, data)` — find, apply changes via model_fields_set, set updated_at, commit
- `delete_task(session, user_id, task_id)` — find, delete, commit
- `toggle_complete(session, user_id, task_id)` — find, flip completed, set updated_at, commit

**Acceptance criteria**:
- All functions have type hints
- All queries filter by user_id
- updated_at is manually refreshed on update/toggle
- model_fields_set used for partial update logic in update_task

### Task 2: Create Route Handlers
**File**: `backend/app/routes/tasks.py`
**Agent**: Backend Agent
**Depends on**: Task 1 (service layer must exist)

Create the router with 6 endpoints following the backend SKILL.md patterns:
- Router prefix `/api/{user_id}/tasks`
- Each handler uses `get_current_user` dependency
- Each handler calls `enforce_user_access`
- Query params validated with regex patterns
- PUT handler validates at least one field is provided
- Correct status codes (200, 201, 204)
- 404 raised when service returns None

**Acceptance criteria**:
- All 6 endpoints defined with correct methods and paths
- All use `response_model=TaskResponse` (except DELETE)
- Auth dependency on every endpoint
- Query params reject invalid values with 422

### Task 3: Wire Router + Error Handling in main.py
**File**: `backend/app/main.py`
**Agent**: Backend Agent
**Depends on**: Task 2 (router must exist to import)

Modifications:
- Import and register `tasks_router`
- Add global exception handler for unhandled Exception (returns 500 with generic message)

**Acceptance criteria**:
- `app.include_router(tasks_router)` is present
- Global exception handler returns JSON with `detail` and `status_code`
- Existing health check, CORS, and lifespan are preserved

### Task 4: Verify (Manual / Swagger)
**Not a code task** — verification instructions in quickstart.

---

## Complexity Tracking

No constitution violations. No complexity justifications needed.

## Risks

1. **`model_fields_set` edge case**: If Pydantic V2's `model_fields_set` behavior differs from expected with SQLModel schemas, the partial update logic may need adjustment. Mitigation: test with explicit null, omitted, and provided field combinations.
2. **Sync session in async handlers**: SQLModel's `Session` is synchronous. FastAPI handles this correctly for sync dependencies in async handlers (runs in threadpool). No action needed but worth noting.
3. **FK constraint on task creation**: If a user_id from the JWT doesn't exist in the `user` table (e.g., Better Auth hasn't synced), the INSERT will fail with a FK violation. Mitigation: Better Auth creates user records before JWT issuance, so this should not occur in practice.
